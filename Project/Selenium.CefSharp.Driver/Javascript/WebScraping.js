
// Generated by CoffeeScript 1.6.3
// except getCssSelectorOF, getElementId and getPathTo handmade customizations
// The code for getCssSelectorOF was partially borrowed from chromium project:
// https://chromium.googlesource.com/chromium/src.git
//

(function () {
    console.log("WebScrapping ver inject scrpt enter " + new Date().getTime() + ", this:" + this);
    if (this.hadBeenLoaded != 'undefined' && this.hadBeenLoaded != null && this.hadBeenLoaded != '') {
        console.log("WebScrapping hadBeenLoaded had been loaded! " + new Date().getTime());
        return;
    }

    if (!Array.from) {
        Array.from = function (el) {
            return Array.apply(this, el);
        }
    }

    this.hadBeenLoaded = new Date().getTime();
    console.log("hadBeenLoaded will been loaded: " + this.hadBeenLoaded);

    // http://www.anyexample.com/webdev/javascript/ie7_javascript_prompt()_alternative.xml

    //var isIE = function () {
    //    var ua = navigator.userAgent;
    //    /* MSIE used to detect old browsers and Trident used to newer ones*/
    //    var is_ie = ua.indexOf("MSIE ") > -1 || ua.indexOf("Trident/") > -1;
    //    return is_ie;
    //};

    /*Array.prototype.myContains = function (needle) {
        for (i in this) {
            if (this[i] == needle) return true;
        }
        return false;
    }*/

    if (typeof console == 'undefined' || console == null || typeof console.log == 'undefined' || typeof console.warn == 'undefined') {
        var iframe = document.createElement("iframe");
        document.body.appendChild(iframe);
        console = iframe.contentWindow.console;
        iframe.contentWindow.display = "none";
    }
    var lastClickTime = new Date().getTime();

    function updateLastClickTime(funcName) {
        var nowTime = new Date().getTime();
        console.log("updateLastClickTime-" + funcName + ", pre:" + lastClickTime + ", now:" + nowTime + ", diff:" + (nowTime - lastClickTime));
        lastClickTime = nowTime;
    }

    function tooNearClick(funcName) {
        var nowTime = new Date().getTime();
        var tooNear = (nowTime - lastClickTime) < 300; // 0.3 seconds
        console.log("tooNearClick-" + funcName + ", pre:" + lastClickTime + ", now:" + nowTime + ", diff:" + (nowTime - lastClickTime) + ", tooNear:" + tooNear);
        return tooNear;
    }

    var SWD_Page_Recorder, addStyle, bye, createCommand, record, dbg, getInputElementsByTypeAndValue, getPageXY, getCssSelectorOF, getElementId, getPathTo, highlightEle, hello, prev, preventEvent, pseudoGuid, say;
    var clickAtHandler, mouseoverHandler, mouseDownAtHandler, typeChangeHandler, TypeInputHandler, doubleClickAtHandler, sendKeysKeyDownHandler, editContentFocusHandler, editContentBlurHandler, loadHandler;
    // var scrollHandler;
    var ELEMENT_NODE = 1;

    say = function (context) {
        if (typeof console !== 'undefined' && console !== null) {
            return console.log(context);
        }
    };

    dbg = function (context) {
        if (typeof console !== 'undefined' && console !== null) {
            return console.log('DBG:' + context);
        }
    };

    hello = function (context) {
        return dbg('(begin): ' + context);
    };

    bye = function (context) {
        return dbg('(end): ' + context);
    };

    pseudoGuid = function () {
        var result;
        hello('pseudoGuid');
        result = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
        result = result.replace(/[xy]/g, function (re_match) {
            var random_value, replacement;
            random_value = Math.random() * 16 | 0;
            replacement = re_match === 'x' ? random_value : random_value & 0x3 | 0x8;
            return replacement.toString(16);
        });
        bye('pseudoGuid');
        return result;
    };

    getInputElementsByTypeAndValue = function (inputType, inputValue) {
        var allDocumentInputElements, inputElement, result, _i, _len;
        hello('getInputElementsByTypeAndValue');
        allDocumentInputElements = document.getElementsByTagName('input');
        result = [];
        for (_i = 0, _len = allDocumentInputElements.length; _i < _len; _i++) {
            inputElement = allDocumentInputElements[_i];
            if (inputElement.type === inputType && inputElement.value === inputValue) {
                result.push(inputElement);
            }
        }
        bye('getInputElementsByTypeAndValue');
        return result;
    };

    // http://stackoverflow.com/questions/6743912/get-the-pure-text-without-html-element-by-javascript
    getText = function (element, addSpaces) {
        var i, result, text, child;
        hello('getText ' + element.tagName);
        if (element.childNodes && element.childNodes > 1) {
            result = '';
            for (i = 0; i < element.childNodes.length; i++) {
                child = element.childNodes[i];
                text = null;
                // NOTE we only collapsing child node values when there is more than one child
                if (child.elementType === 1) {
                    text = getText(child, addSpaces);
                } else if (child.elementType === 3) {
                    text = child.elementValue;
                }
                if (text) {
                    if (addSpaces && /\S$/.test(result) && /^\S/.test(text)) text = ' ' + text;
                    result += text;
                }
            }
        } else {
            result = element.innerText || element.textContent || '';
        }
        result = result.replace(/\r?\n/g, ' ').replace(/\s+/g, ' ').replace(/^\s+/, '').replace(/\s+$/, '');
        bye('getText result: ' + result);
        return result;
    };

    getElementId = function (element) {
        var selector = '';
        hello('getElementId ' + element.tagName);

        if (element instanceof Element && element.nodeType === ELEMENT_NODE && element.id) {
            selector = element.id;
        }
        bye('getElementId');
        return selector;
    };

    // The initial version code of getCssSelectorOF was partially borrowed from chromium project:
    // https://chromium.googlesource.com/chromium/src.git
    getCssSelectorOF = function (element) {
        hello('getCssSelectorOF ' + element.tagName);
        var specialAttributesArray = ['href', 'src', 'title', 'alt', 'name', 'value', 'type', 'action', 'onclick'];
        if (!(element instanceof Element))
            return;
        var path = [];
        while ((element instanceof Element) && element.nodeType === ELEMENT_NODE) {
            var selector = element.nodeName.toLowerCase();
            if (element.id && path.length != 0) {
                if (element.id.indexOf('-') > -1) {
                    selector += '[id = "' + element.id + '"]';
                } else {
                    selector += '#' + element.id;
                }
                path.unshift(selector);
                break;
            } else if (element.className) {
                var attr = element.className;
                // ignore className attributes with special characters
                if (attr.indexOf('(') == -1 /* && attr.indexOf('*') == -1 && attr.indexOf('.') == -1 */) {
                    selector += '.' + attr.replace(/^\s+/, '').replace(/\s+$/, '').replace(/\s+/g, '.');
                }
            } else {
                var element_sibling = element;
                var sibling_cnt = 1;
                while (element_sibling = element_sibling.previousElementSibling) {
                    if (element_sibling.nodeName.toLowerCase() == selector)
                        sibling_cnt++;
                }
                if (sibling_cnt != 1)
                    selector += ':nth-of-type(' + sibling_cnt + ')';
            }
            var arrayLength = specialAttributesArray.length;
            var attribute_conditions_postfix = [];
            var attribute_condition = '';
            var prefix = '';
            var i;
            // refactored to look similarly with getCssSelectorOF and getPathTo
            for (i = 0; i < arrayLength; i++) {
                specialAttribute = specialAttributesArray[i];
                attribute_condition = probeAttribute(element, specialAttribute, prefix);
                if (attribute_condition) {
                    hello('Found attribute condition:' + attribute_condition);
                    attribute_conditions_postfix.push(attribute_condition);
                }
            }
            if (attribute_conditions_postfix.length > 0) {
                for (i = 0; i < attribute_conditions_postfix.length; i++) {
                    selector += '[ ' + attribute_conditions_postfix[i] + ' ]';
                }
                hello('Finished building postfix: ' + element.tagName + ' ' + selector);
            }
            path.unshift(selector);
            element = element.parentNode;
        }
        bye('getCssSelectorOF');
        return path.join(' > ');
    };

    // prefix : '@' for xpath, empty for css.
    probeAttribute = function (element, attributeName, prefix) {
        if (element.hasAttribute(attributeName)) {
            var attribute = element.getAttribute(attributeName);
            if (attribute != null && ((typeof attribute) != 'undefined') && attribute !== '') {
                if (attribute.indexOf('hover') != -1 || attribute.indexOf('highlight') != -1) {

                    if (attribute.indexOf('hover') != -1 && attribute.trim() == "hover") {
                        return null;
                    }

                    if (attribute.indexOf('highlight') != -1 && attribute.trim() == "highlight") {
                        return null;
                    }

                    return prefix + attributeName + ' = "' + attribute.replace(' hover', '').replace(' highlight', '') + '"';
                }
                else {
                    return prefix + attributeName + ' = "' + attribute + '"';
                }
            }
            return prefix + attributeName + ' = "' + attribute + '"';
        } else {
            return null;
        }
    };

    getPathTo = function (element, depth) {
        if (null == element) {
            console.error("getPathTo element is null!");
            return null;
        }
        depth = depth + 1;
        var element_sibling, siblings, cnt, sibling_count;
        var elementTagName = element.tagName.toLowerCase();
        hello('getPathTo ' + elementTagName);

        if (element === document.body) {
            return '/html/' + elementTagName;
        }

        sibling_count = 0;
        siblings = element.parentNode.childNodes;
        siblings_length = siblings.length;
        for (cnt = 0; cnt < siblings_length; cnt++) {
            element_sibling = siblings[cnt];

            if (element_sibling.nodeType !== ELEMENT_NODE) { // not ELEMENT_NODE
                continue;
            }

            if (element_sibling === element) {
                var attributeClass = probeAttribute(element, "class", '@');
                if (attributeClass !== null && attributeClass !== '') {
                    return getPathTo(element.parentNode, depth) + '/' + elementTagName + '[' + attributeClass + ']';
                }
                else {
                    return getPathTo(element.parentNode, depth) + '/' + elementTagName;
                }
            }
            if (element_sibling.nodeType === 1 && element_sibling.tagName.toLowerCase() === elementTagName) {
                sibling_count++;
            }
        }
        return bye('getPathTo ' + elementTagName);
    };

    // simplified
    // ng12Hybrid detection not supported yet
    // not functional yet
    testForAngular = function () {
        hello('testForAngular');
        var isAngular = (window.angular && window.angular.resumeBootstrap) ?
            true : false;
        return bye('testForAngular ' + isAngular);
    };

    getProtractorLocators = function (element) {
        hello('getProtractorLocators');
        var specialAttributesArray = ['ng-repeat', 'ng-binding', 'ng-model', 'ng-option'];
        var attribute_postfix = [];
        var postfix = '';
        var arrayLength = specialAttributesArray.length;
        for (var i = 0; i < arrayLength; i++) {
            specialAttribute = specialAttributesArray[i];
            postfix = probeAttribute(element, specialAttribute, '@');
            if (postfix) {
                hello('Found postfix:' + postfix);
                attribute_postfix.push(postfix);
            }
        }
        bye('getProtractorLocators ' + attribute_postfix.join(','));
    };


    getPageXY = function (element) {
        var x, y;
        hello('getPageXY');
        x = 0;
        y = 0;
        while (element) {
            x += element.offsetLeft;
            y += element.offsetTop;
            element = element.offsetParent;
        }
        bye('getPageXY');
        return [x, y];
    };

    createCommand = function (jsonData) {
        var myJSONText;
        hello('createCommand');
        //if (isIE()) {
        //    myJSONText = jsonData;
        //    if (window.clipboardData) { // Internet Explorer
        //        var commands = window.clipboardData.getData("Text");
        //        var recorderCommands = [];
        //        var commands_json = {};
        //        try {
        //            commands_json = JSON.parse(commands);
        //        } catch (e) {

        //        }

        //        if (commands_json === undefined || commands_json === null) {
        //            commands_json = {};
        //        }

        //        if (commands_json.hasOwnProperty('RecorderCommands')) {
        //            recorderCommands = commands_json.RecorderCommands;
        //            if (recorderCommands != undefined) {
        //                if (recorderCommands.length > 10) {
        //                    recorderCommands.shift();
        //                }
        //            }
        //        }
        //        recorderCommands.push(myJSONText);
        //        commands_json.RecorderCommands = recorderCommands;
        //        window.clipboardData.setData("Text", JSON.stringify(commands_json));
        //    }
        //} else {
        myJSONText = JSON.stringify(jsonData).replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
        document.swdpr_command.push(myJSONText);
        if (typeof console !== 'undefined' && console !== null) {
            return console.warn('RecorderCommand:' + myJSONText);
        }
        //}
        return bye('createCommand ' + myJSONText);
    };

    record = function (cmd, target, value, columnName) {
        if (null == target) {
            console.error("record target is null!");
            return;
        }
        var jsonData, xpath, css_selector, id, elementText, tagName, relative_x, relative_y, width, height;

        if (target != "") {
            if (columnName != null && columnName != "" && webScrappingXPath != null && webScrappingXPath != "") {
                xpath = webScrappingXPath;
            }
            else {
                xpath = getPathTo(target, 0);
            }

            css_selector = getCssSelectorOF(target);
            var dummy = getProtractorLocators(target);
            id = getElementId(target);
            elementText = getText(target, true);
            tagName = target.tagName;
            rectInfo = target.getBoundingClientRect();
            relative_x = rectInfo.left;
            relative_y = rectInfo.top;
            width = rectInfo.width;
            height = rectInfo.height;
        }

        jsonData = {
            'Command': cmd,
            'Caller': 'Recorder',
            'CommandId': pseudoGuid(),
            'CommandValue': value,
            'CssSelector': css_selector,
            'XPathValue': xpath,
            'ElementId': id,
            'ElementText': elementText,
            'ElementTagName': tagName,
            'Relative_X': relative_x,
            'Relative_Y': relative_y,
            'Width': width,
            'Height': height,
            'ColumnName': columnName
        };

        createCommand(jsonData);
    };

    addStyle = function (css) {
        var head, style;
        //hello('addStyle');
        head = document.getElementsByTagName('head')[0];
        style = document.createElement('style');
        style.type = 'text/css';
        if (style.styleSheet) {
            style.styleSheet.cssText = css;
        } else {
            style.appendChild(document.createTextNode(css));
        }
        head.appendChild(style);
        return bye('addStyle');
    };

    preventEvent = function (event) {
        hello('preventEvent');
        event = event || window.event;
        if (event.preventDefault) {
            event.preventDefault();
        }
        event.returnValue = false;
        if (event.stopPropagation) {
            event.stopPropagation();
        } else {
        }
        if (window.event) {
            window.event.cancelBubble = true;
            window.event.returnValue = false;
        }
        event.cancelBubble = true;
        bye('preventEvent');
        return false;
    };

    prev = void 0;

    document.Swd_prevActiveElement = void 0;

    highlightEle = function (event) {
        hello('highlightEle');
        if (document.SWD_Page_Recorder == null) {
            return;
        }
        if (event.target === document.body || prev === event.target) {
            return;
        }
        if (prev) {
            prev.className = prev.className.replace(/\s?\bhighlight\b/, '');
            prev = void 0;
        }
        if (event.target) {
            prev = event.target;
            prev.className += ' highlight';
        }
        setTimeout(function () { event.target.classList.remove('highlight'); }, 1000);
        return bye('highlightEle');
    };

    var typeTarget;
    var typeLock = 0;
    var focusTarget = null;
    var focusValue = null;
    var tempValue = null;
    var preventType = false;
    var inputTypes = ["text", "password", "file", "datetime", "datetime-local", "date", "month", "time", "week", "number", "range", "email", "url", "search", "tel", "color"];

    typeChangeHandler = function (event) {
        console.log(document.SWD_Page_Recorder_Enabled);
        if (document.SWD_Page_Recorder_Enabled) {
            if (event.target.tagName && !preventType && typeLock == 0 && (typeLock = 1)) {
                // END
                var tagName = event.target.tagName.toLowerCase();
                var type = event.target.type;
                if ("input" == tagName && inputTypes.indexOf(type) >= 0) {
                    if (event.target.value.length > 0) {
                        record("type", event.target, event.target.value, "");

                        if (enterTarget != null) {
                            var tempTarget = event.target.parentElement;
                            var formChk = tempTarget.tagName.toLowerCase();
                            while (formChk != "form" && formChk != "body") {
                                tempTarget = tempTarget.parentElement;
                                formChk = tempTarget.tagName.toLowerCase();
                            }
                            if (formChk == "form" && (tempTarget.hasAttribute("id") || tempTarget.hasAttribute("name")) && (!tempTarget.hasAttribute("onsubmit"))) {
                                if (tempTarget.hasAttribute("id"))
                                    record("submit", "", "id=" + tempTarget.id, "");
                                else if (tempTarget.hasAttribute("name"))
                                    record("submit", "", "name=" + tempTarget.name, "");
                            } else
                                record("sendKeys", enterTarget, "${KEY_ENTER}", "");
                            enterTarget = null;
                        }
                        // END
                    } else {
                        record("type", event.target, event.target.value, "");
                    }
                } else if ("textarea" == tagName) {
                    record("type", event.target, event.target.value, "");
                }
            }
        }
        typeLock = 0;
    };

    TypeInputHandler = function (event) {
        console.log("TypeInputHandler", document.SWD_Page_Recorder_Enabled);
        if (!document.SWD_Page_Recorder_Enabled)
            return;
        typeTarget = event.target;
    };

    clickAtHandler = function (event) {
        event = event || window.event;
        console.log(document.SWD_Page_Recorder_Enabled);
        if (document.SWD_Page_Recorder_Enabled) {
            console.log("clickAtHandler stop click", arguments);
            if (event.button == 0 && !preventClick && event.isTrusted) {
                if (event.preventDefault) {
                    event.preventDefault();
                }
                event.returnValue = false;
                if (event.stopPropagation) {
                    event.stopPropagation();
                } else {
                }
                event.cancelBubble = true;
                if (window.event) {
                    window.event.cancelBubble = true;
                    window.event.returnValue = false;
                }
                if (!tooNearClick("clickAtHandler")) {
                    record("click", event.target, event.currentTarget.URL, "");
                    updateLastClickTime("clickAtHandler");
                    highlightEle(event);
                }
                return false;
            }
            else {
                console.log("clickAtHandler allow click inner", arguments);
            }
        }
        else {
            console.log("clickAtHandler allow click out", arguments);
        }
    };

    //var common_xpath_error_FindNodeSelfFailed = "FindNodeSelfFailed";
    //var common_xpath_error_DifferentTag = "DifferentTag";
    //var common_xpath_error_HtmlTagNotFound = "HtmlTagNotFound";
    //var common_xpath_errors = [common_xpath_error_FindNodeSelfFailed, common_xpath_error_DifferentTag, common_xpath_error_HtmlTagNotFound];
    //var list_item_tags = ["li", "dt", "dd", "tr"];
    var web_scrapping_xpath_spliter = ";;";    // must be same as ActiveityScrapping.cs
    var clickCount = 0;
    var preEventTarget = null;
    var preCurrentTargetURL = "";
    var preClassName = "";
    var webScrappingXPath = null;
    var itemsParentXPath = null;
    var lastRecordXPath = null;
    mouseDownAtHandler = function (event) {
        event = event || window.event;
        console.log("Down arg:" + arguments);
        console.log("Down ctrl:" + event.ctrlKey + ", E:" + document.SWD_Page_Recorder_Enabled);
        if (document.SWD_Page_Recorder_Enabled && event.ctrlKey) {
            if (event.button == 0 && event.isTrusted) {
                if (event.preventDefault) {
                    event.preventDefault();
                }
                event.returnValue = false;
                if (event.stopPropagation) {
                    event.stopPropagation();
                } else {
                }
                event.cancelBubble = true;
                if (window.event) {
                    window.event.cancelBubble = true;
                    window.event.returnValue = false;
                }

                var curTag = event.target.tagName.toLowerCase();
                if (curTag == "html" || curTag == "body") {
                    console.log("Skip html and body");
                    return false;
                }
                if (tooNearClick("mouseDownAtHandler#1")) {
                    // preEventTarget = event.target;
                    // preCurrentTargetURL = event.currentTarget.URL;
                    // preClassName = preEventTarget.className;
                    // clickCount = 1;
                    return false;
                }
                else {
                    updateLastClickTime("mouseDownAtHandler#2");

                    var isNextPageCtrl = false;
                    if (preEventTarget == event.target) {
                        var result = confirm("Do you want to add this as next page control?");
                        updateLastClickTime("mouseDownAtHandler#3");
                        if (result) {
                            isNextPageCtrl = true;
                        } else {
                            console.log("Skip same target element preEventTarget:" + preEventTarget);
                            return false;
                        }
                    }

                    clickCount = clickCount + 1;
                    if (clickCount == 1) {
                        preEventTarget = event.target;
                        preCurrentTargetURL = event.currentTarget.URL;
                        preClassName = preEventTarget.className;
                    }
                    else if (clickCount == 2) {
                        // https://www.amazon.com/s?k=cellphone&amp;ref=nb_sb_noss_1
                        var isError = false;
                        var commonXPathInfo = null;
                        try {
                            commonXPathInfo = calcCommonXPath(preEventTarget, event.target);
                        }
                        catch (error) {
                            console.log("mouseDownAtHandler failed! err:" + error);
                            isError = true;
                        }

                        if (isError) {
                            clickCount = 1;
                            preEventTarget = event.target;
                            preCurrentTargetURL = event.currentTarget.URL;
                            preClassName = preEventTarget.className;
                        }
                        else if (null != lastRecordXPath && lastRecordXPath.parentXPath == commonXPathInfo.parentXPath && lastRecordXPath.subXPaths == commonXPathInfo.subXPaths) {
                            console.warn("mouseDownAtHandler skip same field lastRecordXPath:" + lastRecordXPath + ", target:" + event.target);
                            clickCount = 0;
                            preEventTarget = null;
                            preCurrentTargetURL = "";
                            preClassName = "";
                            webScrappingXPath = "";
                        }
                        //else {
                        //    webScrappingXPath = commonXPathInfo.parentXPath + web_scrapping_xpath_spliter + commonXPathInfo.subXPaths;
                        //    if (isNextPageCtrl) {
                        //        if ((typeof preClassName == 'undefined') && ((typeof event.target.className) != 'undefined')) {
                        //            //event.target.removeAttribute("class");
                        //        }
                        //        else {
                        //            preEventTarget.className = preClassName;
                        //        }
                        //        record("click", preEventTarget, preCurrentTargetURL, "NextPage");
                        //        record("click", event.target, event.currentTarget.URL, "NextPage");
                        //        lastRecordXPath = commonXPathInfo;
                        //    } else {
                        //        var columnName = window.prompt("Please give title for this field:");
                        //        updateLastClickTime("mouseDownAtHandler#4");
                        //        if (columnName == "" || columnName == null) {
                        //            record("click", preEventTarget, preCurrentTargetURL, "Cancel");
                        //            record("click", event.target, event.currentTarget.URL, "Cancel");
                        //        }
                        //        else {
                        //            if (null != itemsParentXPath) {
                        //                var compatibleXPath = calcCompatibleXPath(itemsParentXPath, commonXPathInfo.parentXPath);
                        //                if (null == compatibleXPath) {
                        //                    console.log("Can't add different list to 1 scrapping node prev:" + itemsParentXPath + ", new:" + commonXPathInfo.parentXPath);
                        //                    alert("Can't add different list to 1 scrapping node!");

                        //                    clickCount = 0;
                        //                    preEventTarget = null;
                        //                    preCurrentTargetURL = "";
                        //                    preClassName = "";
                        //                    webScrappingXPath = "";
                        //                    updateLastClickTime("mouseDownAtHandler#5");
                        //                    return false;
                        //                }
                        //                else {
                        //                    itemsParentXPath = compatibleXPath;
                        //                    webScrappingXPath = compatibleXPath + web_scrapping_xpath_spliter + commonXPathInfo.subXPaths;
                        //                }
                        //            }
                        //            else {
                        //                itemsParentXPath = commonXPathInfo.parentXPath;
                        //            }

                        //            if (preEventTarget == event.target && (typeof preClassName == 'undefined') && ((typeof event.target.className) != 'undefined')) {
                        //                //event.target.removeAttribute("class");
                        //            }
                        //            else {
                        //                preEventTarget.className = preClassName;
                        //            }
                        //            record("click", preEventTarget, preCurrentTargetURL, columnName);
                        //            record("click", event.target, event.currentTarget.URL, columnName);
                        //            lastRecordXPath = commonXPathInfo;
                        //        }
                        //    }
                        //}
                    }

                    if (clickCount >= 2) {
                        clickCount = 0;
                        preEventTarget = null;
                        preCurrentTargetURL = "";
                        preClassName = "";
                        webScrappingXPath = "";
                    }
                    updateLastClickTime("mouseDownAtHandler#6");
                    highlightEle(event);
                }
                return false;
            }
            else {
                console.log("mouseDownAtHandler allow click not trusted", arguments);
            }
        }
        else {
            console.log("mouseDownAtHandler allow click", arguments);
        }
    };

    function calcCommonXPath(ele1, ele2) {
        var nodeSubXPath = "";
        var subXPaths = "";
        var tags1 = [];
        var tags2 = [];

        var parentXPathInfo = calcParentXPath(ele1, ele2, tags1, tags2);
        var parentXPath = parentXPathInfo.parentXPath;
        var parentLevelUnderBody = parentXPathInfo.parentLevelUnderBody;

        if (ele1 != ele2) { // Not "Next page"
            var totalLevelsUnderBody1 = tags1.length;
            var totalLevelsUnderBody2 = tags2.length;

            var maxBottomLevels = Math.min(totalLevelsUnderBody1 - parentLevelUnderBody, totalLevelsUnderBody2 - parentLevelUnderBody);
            var commonXPathLevels = 0;

            var currentNode1 = ele1;
            var currentNode2 = ele2;
            var currentTag1 = currentNode1.nodeName.toLowerCase();
            var currentTag2 = currentNode2.nodeName.toLowerCase();
            while (currentTag1 == currentTag2 && commonXPathLevels < maxBottomLevels) {
                ++commonXPathLevels;
                nodeSubXPath = calcNodeSubXPath(currentNode1, currentNode2);
                subXPaths = nodeSubXPath + subXPaths;

                currentNode1 = currentNode1.parentNode;
                currentNode2 = currentNode2.parentNode;
                currentTag1 = currentNode1.nodeName.toLowerCase();
                currentTag2 = currentNode2.nodeName.toLowerCase();
            }

            if (currentTag1 != currentTag2) { // Different levels of XPath, no common parts
                if (4 <= commonXPathLevels) { //
                    console.log("calcCommonXPath commonXPathLevels is enough  ", parentXPath, "####", commonXPathLevels, "####", subXPaths, "####", currentTag1, "####", currentTag2, "####", ele1, ele2);
                }
                else {
                    console.log("calcCommonXPath Tags are different! ", parentXPath, "####", commonXPathLevels, "####", subXPaths, "####", currentTag1, "####", currentTag2, "####", ele1, "####", ele2);
                    err = new Error('Failed to find common for different tag! level:' + i);
                    throw err;
                }
            } else {
                console.log("calcCommonXPath Found normal ", currentTag1, "####", currentTag2, "####", ele1, "####", ele2);
            }
        }
        else {
            subXPaths = "";
        }

        return { "parentXPath": parentXPath, "subXPaths": subXPaths };
    }

    function calcNodeSubXPath(currentNode1, currentNode2) {
        var currentTag1 = currentNode1.nodeName.toLowerCase();
        var currentTag2 = currentNode2.nodeName.toLowerCase();

        var class1 = removeDynamicClassWord(currentNode1.className);
        var class2 = removeDynamicClassWord(currentNode2.className);

        var classExp = calcCommonClassExpress(currentNode1, currentNode2);
        var commonClass = classExp.commonClass;
        var searchClass = classExp.searchClass;

        var parent1 = currentNode1.parentNode;  // TODO: Should consider case: If tag body can't be found
        var parent2 = currentNode2.parentNode;

        var nodeSubXPath = "/" + currentTag1 + commonClass;

        var sameClassNodes1 = false, sameClassNodes2 = false;
        if (null != searchClass) {
            sameClassNodes1 = getDirectElementsByClassName(parent1, currentTag1, searchClass);
            sameClassNodes2 = getDirectElementsByClassName(parent2, currentTag2, searchClass);
        } else {
            sameClassNodes1 = getDirectElementsByClassNames(parent1, currentTag1, class1, class2);
            sameClassNodes2 = getDirectElementsByClassNames(parent2, currentTag2, class1, class2);
        }

        var index1 = getNodeIndex(currentNode1, sameClassNodes1);
        var index2 = getNodeIndex(currentNode2, sameClassNodes2);
        if (index1 == -1 || index2 == -1) {
            console.log("Can't find node self ", index1, "######", index2, "######", currentNode1, "######", currentNode2, "######", searchClass, "######", commonClass);
            err = new Error('calcNodeXPath index different!');
            throw err;
        }
        if (index1 == index2) {
            nodeSubXPath += "[" + index1 + "]";
        }
        return nodeSubXPath;
    }

    function calcElementXPathInfo(ele, nodes, tags, classes) {
        var currentTag = ele.nodeName.toLowerCase();
        var currentNode = ele;
        var className;
        while (currentTag != 'body') {
            tags.unshift(currentTag);
            nodes.unshift(currentNode);

            className = removeDynamicClassWord(currentNode.className);
            classes.unshift(className);

            currentNode = currentNode.parentNode;
            currentTag = currentNode.nodeName.toLowerCase();
        }
    }

    var class_exp_no_class = "not(@class)"; // No class
    var class_exp_no_or_empty_class = 'not(@class) or (@class ="")';
    function calcCompatibleXPath(xpath1, xpath2) {
        var result;
        if (xpath1 == xpath2) {
            result = xpath1;
        }
        else {
            var xpathParts1 = xpath1.split("/");
            var xpathParts2 = xpath2.split("/");
            if (xpathParts1.length != xpathParts2.length) {
                result = null;
            }
            else {
                var partNum = xpathParts1.length;
                var allPrevSame = true;
                var i;
                for (i = 0; i < partNum - 1; ++i) {
                    if (xpathParts1[i] != xpathParts2[i]) {
                        allPrevSame = false;
                        break;
                    }
                }
                if (!allPrevSame) {
                    result = null;
                }
                else {
                    nodeInfo1 = resolveInfoFromXPathNode(xpathParts1[partNum - 1]);
                    nodeInfo2 = resolveInfoFromXPathNode(xpathParts2[partNum - 1]);
                    if (nodeInfo1.tag != nodeInfo2.tag || null != nodeInfo1.index || null != nodeInfo2.index) {
                        result = null;
                    }
                    else {
                        if (nodeInfo1.classResult == nodeInfo2.classResult) {
                            result = xpath1;
                        }
                        else {
                            var newXPathNode;
                            if (null == nodeInfo1.classResult || null == nodeInfo2.classResult) {
                                newXPathNode = nodeInfo1.tag;
                            }
                            else {
                                if (class_exp_no_class == nodeInfo1.classResult || class_exp_no_or_empty_class == nodeInfo1.classResult
                                    || class_exp_no_class == nodeInfo2.classResult || class_exp_no_or_empty_class == nodeInfo2.classResult
                                    || (0 <= nodeInfo1.classResult.indexOf(class_exp_no_class)) || (0 <= nodeInfo2.classResult.indexOf(class_exp_no_class))) {
                                    newXPathNode = makeXPathNodeExpress(nodeInfo1.tag, nodeInfo1.originClassExp, nodeInfo2.originClassExp);
                                }
                                else {
                                    subCommonClasses = calcCommonWords(nodeInfo1.originClassExp, nodeInfo2.originClassExp);    // Split to words by space, than calculate commond words
                                    if (subCommonClasses.length == 0) {
                                        // No common pars
                                        newXPathNode = nodeInfo1.tag;
                                    } else {
                                        searchClass = subCommonClasses.join(' ');
                                        commonClass = "[";
                                        for (i = 0; i < subCommonClasses.length; i++) {
                                            var subClass = subCommonClasses[i];
                                            commonClass += makeContainsClassExpress(subClass);
                                            if (i != subCommonClasses.length - 1) {
                                                commonClass += " and ";
                                            }
                                        }
                                        commonClass += "]";
                                        newXPathNode = nodeInfo1.tag + commonClass;
                                    }
                                }
                            }
                            xpathParts1[partNum - 1] = newXPathNode;
                            result = xpathParts1.join("/");
                        }
                    }
                }
            }
        }
        return result;
    }

    var contains_cat_exp_starter = 'contains(concat(" ",@class," ")," ';
    function makeContainsClassExpress(subClass) {
        return contains_cat_exp_starter + subClass + ' ")';
    }

    function makeXPathNodeExpress(tag, classExp1, classExp2) {
        return tag + "[(" + classExp1 + ") or (" + classExp2 + ")]";
    }

    function resolveInfoFromXPathNode(xpathNode) {
        var re = /^([a-zA-Z0-9\-_]+)(\[([@a-zA-Z ]+[^\]]*)\])?(\[(\d+)\])?$/;
        var matches = re.exec(xpathNode);

        var result;
        if (null == matches) {
            result = null;
            console.log("resolveInfoFromXPathNode not valid xpathNode ", xpathNode);
            err = new Error("resolveInfoFromXPathNode not valid xpathNode:" + xpathNode);
            throw err;
        }
        else {
            var tag = matches[1];
            if (null == tag) {
                console.log("resolveInfoFromXPathNode not valid xpathNode tag is null ", xpathNode);
                err = new Error("resolveInfoFromXPathNode not valid xpathNodee tag is null:" + xpathNode);
                throw err;
            }

            var classExp = matches[3];
            var classResult;
            if (null == classExp) {
                classResult = null;
            }
            else if (class_exp_no_class == classExp || class_exp_no_or_empty_class == classExp) {
                classResult = classExp;
            }
            else if (0 <= classExp.indexOf(class_exp_no_class)) {
                classResult = classExp;
            }
            else {
                var pureClasses = classExp.replace(contains_cat_exp_starter, " ");
                pureClasses = pureClasses.replace('")', " ");
                pureClasses = pureClasses.replace('and")', " ");
                var classParts = pureClasses.split("[ ]+");
                classResult = [];
                for (var i = 0; i < classParts.length; i++) {
                    if ((null != classParts[i]) && ('' != classParts[i]) && (' ' != classParts[i])) {
                        classResult[classResult.length] = classParts[i];
                    }
                }
            }
            result = { "tag": tag, "classes": classResult, "index": matches[5], "originClassExp": classExp };
        }
        return result;
    }

    function getNodeIndex(currentNode, sameClassNodes) {
        if (!sameClassNodes) {
            console.log("No silbing nodes ", currentNode, sameClassNodes);
            return -1;
        }
        var allNodes = Array.from(sameClassNodes);
        for (var i = 0; i < allNodes.length; i++) {
            if (allNodes[i] == currentNode) {
                return (parseInt(i) + 1);
            }
        }
        console.log("getNodeIndex Can't find myself ", currentNode, sameClassNodes);
        return -1;
    }

    function calcCommonClassExpress(currentNode1, currentNode2) {
        var class1 = removeDynamicClassWord(currentNode1.className);
        var class2 = removeDynamicClassWord(currentNode2.className);
        var subCommonClasses;
        var searchClass = null;
        var commonClass = "";
        var i;
        var subClass;
        if (class1 == class2) {
            if ("undefined" == class1) {
                commonClass = "[" + class_exp_no_class + "]"; // No class
            } else if ("" == class1) {
                commonClass = '[' + class_exp_no_or_empty_class + ']'; // No class
            } else {
                //if (noDynamicClassWord1) {
                //    commonClass = '[@class ="' + class1 + '"]'; // Use it directly
                //    searchClass = class1; // should compare completely
                //} else
                {
                    subCommonClasses = class1.split(" ");    // Split to words by space, than calculate commond words
                    if (subCommonClasses.length == 0) {
                        // No common pars
                        commonClass = "";
                    } else {
                        searchClass = class1;
                        commonClass = "[";
                        for (i = 0; i < subCommonClasses.length; i++) {
                            subClass = subCommonClasses[i];
                            commonClass += makeContainsClassExpress(subClass);
                            if (i != subCommonClasses.length - 1) {
                                commonClass += " and ";
                            }
                        }
                        commonClass += "]";
                    }
                }
            }
        } else {
            if ("undefined" == class1) {
                commonClass = '[not(@class) or ';   // (@class ="' + class2 + '")]'; // Only class2 has class
                //if (noDynamicClassWord2) {
                //    commonClass += '(@class ="' + class2 + '")]'; // Use it directly
                //} else
                {
                    subCommonClasses = class2.split(" ");    // Split to words by space, than calculate commond words
                    if (subCommonClasses.length == 0) {
                        // No common pars
                        commonClass = "";
                    } else {
                        searchClass = class2;
                        commonClass += "(";
                        for (i = 0; i < subCommonClasses.length; i++) {
                            subClass = subCommonClasses[i];
                            commonClass += makeContainsClassExpress(subClass);
                            if (i != subCommonClasses.length - 1) {
                                commonClass += " and ";
                            }
                        }
                        commonClass += ")]";
                    }
                }
            } else if ("undefined" == class2) {
                commonClass = '[not(@class) or ';   // (@class ="' + class1 + '")]'; // Only class2 has class
                //if (noDynamicClassWord1) {
                //    commonClass += '(@class ="' + class1 + '")]'; // Use it directly
                //}
                //else
                {
                    subCommonClasses = class1.split(" ");    // Split to words by space, than calculate commond words
                    if (subCommonClasses.length == 0) {
                        // No common pars
                        commonClass = "";
                    } else {
                        searchClass = class1;
                        commonClass += "(";
                        for (i = 0; i < subCommonClasses.length; i++) {
                            subClass = subCommonClasses[i];
                            commonClass += makeContainsClassExpress(subClass);
                            if (i != subCommonClasses.length - 1) {
                                commonClass += " and ";
                            }
                        }
                        commonClass += ")]";
                    }
                }
            } else {
                subCommonClasses = calcCommonWords(class1, class2);    // Split to words by space, than calculate commond words
                if (subCommonClasses.length == 0) {
                    // No common pars
                    commonClass = "";
                } else {
                    searchClass = subCommonClasses.join(' ');
                    commonClass = "[";
                    for (i = 0; i < subCommonClasses.length; i++) {
                        subClass = subCommonClasses[i];
                        commonClass += makeContainsClassExpress(subClass);
                        if (i != subCommonClasses.length - 1) {
                            commonClass += " and ";
                        }
                    }
                    commonClass += "]";
                }
            }
        }
        return { "commonClass": commonClass, "searchClass": searchClass };
    }

    function calcParentXPath(ele1, ele2, tags1, tags2) {
        var nodes1 = [];
        var classes1 = [];
        var nodes2 = [];
        var classes2 = [];
        calcElementXPathInfo(ele1, nodes1, tags1, classes1);
        calcElementXPathInfo(ele2, nodes2, tags2, classes2);
        var minCount = Math.min(tags1.length, tags2.length);

        var parent1;
        var currentNode1;
        var currentNode2;
        var currentTag1;
        var currentTag2;
        var nodeSubXPath = '';
        var completeXPath = "";
        for (var i = 0; i < minCount; ++i) {    // skip /html/body
            currentNode1 = nodes1[i];
            currentNode2 = nodes2[i];
            currentTag1 = tags1[i];
            currentTag2 = tags2[i];
            parent1 = currentNode1.parentNode;  // TODO: Should consider case: If tag body can't be found
            parent2 = currentNode2.parentNode;

            if (currentNode1 != currentNode2) {
                if (parent1 != parent2) {
                    console.log("calcParentXPath parent diff ", completeXPath, currentTag1, currentTag2);
                    break;
                }

                if (currentTag1 != currentTag2) {
                    console.log("calcParentXPath same parent but diff tag! ", parent1, "######", currentTag1, "######", currentTag2, "######", i, "######", completeXPath);
                    err = new Error("calcParentXPath same parent but diff tag! 1:" + currentTag1 + ", 2:" + currentTag2 + ", level:" + i);
                    throw err;
                }
            }

            nodeSubXPath = calcNodeSubXPath(currentNode1, currentNode2);
            completeXPath += nodeSubXPath;
        }

        return { "parentXPath": "/html/body" + completeXPath, "parentLevelUnderBody": i };
    }

    function getDirectElementsByClassName(parentNode, eleTag, className) {
        var directNodes = [];
        var trimClassName = className.trim();

        var allNodes = [];
        var i;
        if ("" == trimClassName) { // "" or " "
            allNodes = getDirectElementsByTag(parentNode, eleTag);
            for (i = 0; i < allNodes.length; i++) {// for (var i in allNodes) {
                if (allNodes[i].className == className) {
                    directNodes.push(allNodes[i]);
                } else {
                    console.log("getDirectElementsByClassName class not matched! nodeClass:", allNodes[i].className, ", className", className);
                }
            }
        } else {
            allNodes = parentNode.getElementsByClassName(className);
            for (i = 0; i < allNodes.length; i++) {// for (var i in allNodes) {
                if (allNodes[i].parentNode == parentNode) {
                    directNodes.push(allNodes[i]);
                }
            }
        }

        return directNodes;
    }

    function getDirectElementsByClassNames(parentNode, eleTag, className1, className2) {
        var directNodes = [];
        var allNodes = getDirectElementsByTag(parentNode, eleTag);
        var ignoredWords = ["hover", "highlight"];
        for (var i = 0; i < allNodes.length; i++) {// for (var i in allNodes) {
            if (wordListSameNoOrderIgnoreSpaces(allNodes[i].className, className1, ignoredWords) || wordListSameNoOrderIgnoreSpaces(allNodes[i].className, className2, ignoredWords)) {
                directNodes.push(allNodes[i]);
            } else {
                console.log("getDirectElementsByClassNames class not matched! nodeClass:", allNodes[i].className,
                    ", className1", className1, ", className2", className2);
            }
        }
        return directNodes;
    }

    function getDirectElementsByTag(parentNode, eleTag) {
        var directNodes = [];
        var allTagEles = parentNode.getElementsByTagName(eleTag);
        var allNodes = Array.from(allTagEles);
        for (var i = 0; i < allNodes.length; i++) {// for (var i in allNodes) {
            if (allNodes[i].parentNode == parentNode) {
                directNodes.push(allNodes[i]);
            }
        }
        return directNodes;
    }
    function wordListSameNoOrderIgnoreSpaces(str1, str2, ignoredWords) {
        var isSame = str1 == str2;
        if (!isSame) {
            if (null != str1 && null != str2) {
                var trimStr1 = str1.trim();
                var trimStr2 = str2.trim();
                isSame = trimStr1 == trimStr2;
                if (!isSame) {
                    var words1 = removeWords(str2ValidWords(trimStr1), ignoredWords);
                    var words2 = removeWords(str2ValidWords(trimStr2), ignoredWords);
                    isSame = true;
                    var i;
                    for (i = 0; i < words1.length; i++) {
                        if (-1 == words2.indexOf(words1[i])) {
                            isSame = false;
                            break;
                        }
                    }
                    if (isSame) {
                        for (i = 0; i < words2.length; i++) {
                            if (-1 == words1.indexOf(words2[i])) {
                                isSame = false;
                                break;
                            }
                        }
                    }
                }
            }
        }
        return isSame;
    }

    function calcCommonWords(class1, class2) {
        var subCommonClasses = [];
        var arrClass1 = class1.split(' ');// multiple spaces
        var arrClass2 = class2.split(' ');
        for (var i = 0; i < arrClass1.length; i++) { // {for (var i in arrClass1) {
            if (arrClass1[i] == 'undefined' || arrClass1[i] == '' || arrClass1[i] == ' ' || "unique" == i) {
                continue;
            }
            for (var j = 0; j < arrClass2.length; j++) { // for (var j in arrClass2) {
                if (arrClass1[i] == arrClass2[j] && "unique" != j) {
                    if (subCommonClasses.length > 0) {
                        if (subCommonClasses.indexOf(arrClass1[i]) == -1) {
                            subCommonClasses.push(arrClass1[i]);
                        }
                    } else {
                        subCommonClasses.push(arrClass1[i]);
                    }
                    break;
                }
            }
        }
        return subCommonClasses;
    }
    function removeDynamicClassWord(className) {
        var resultClass;
        if ('' == className || " " == className || "undefined" == className) {
            resultClass = className;
        } else {
            resultClass = '';
            var word;
            var classWords = className.split(' ');// multiple spaces
            for (var i = 0; i < classWords.length; i++) { // for (var i in classWords) {
                word = classWords[i];
                if (word == '' || word == ' ' || "hover" == word || "highlight" == word || "unique" == i) {
                    continue;
                }
                resultClass += ('' != resultClass ? " " : "") + word;
            }
        }
        return resultClass;
    }

    function removeWords(srcWords, toBeRemovedWords) {
        var resultWords = [];
        if (null != srcWords) {
            for (var i = 0; i < srcWords.length; i++) {
                word = srcWords[i];
                if (toBeRemovedWords.indexOf(word) != -1) {
                    continue;
                }
                resultWords.push(word);
            }
        }

        return resultWords;
    }

    function str2ValidWords(str) {
        var resultWords = [];
        var words = str.split(' ');
        for (var i = 0; i < words.length; i++) {
            word = words[i];
            if (word == '' || word == ' ' || "unique" == i) {
                continue;
            }
            resultWords.push(word);
        }
        return resultWords;
    }

    doubleClickAtHandler = function (event) {
        console.log(document.SWD_Page_Recorder_Enabled);
        if (document.SWD_Page_Recorder_Enabled && event.ctrlKey) {
            record("doubleClick", event.target, "", "");
        }
    };

    var inp = document.getElementsByTagName("input");
    for (var i = 0; i < inp.length; i++) {
        if (inputTypes.indexOf(inp[i].type) >= 0) {
            inp[i].addEventListener("focus", function (event) {
                focusTarget = event.target;
                focusValue = focusTarget.value;
                tempValue = focusValue;
                preventType = false;
            });
            inp[i].addEventListener("blur", function () {
                focusTarget = null;
                focusValue = null;
                tempValue = null;
            });
        }
    }
    // END

    var preventClick = false;
    var enterTarget = null;
    var enterValue = null;
    var tabCheck = null;
    sendKeysKeyDownHandler = function (event) {
        console.log(document.SWD_Page_Recorder_Enabled);
        if (document.SWD_Page_Recorder_Enabled) {
            if (event.target.tagName) {
                var key = event.keyCode;
                var tagName = event.target.tagName.toLowerCase();
                var type = event.target.type;
                if (tagName == "input" && inputTypes.indexOf(type) >= 0) {
                    if (key == 13) {
                        enterTarget = event.target;
                        enterValue = enterTarget.value;
                        var tempTarget = event.target.parentElement;
                        var formChk = tempTarget.tagName.toLowerCase();

                        if (tempValue == enterTarget.value && tabCheck == enterTarget) {
                            record("sendKeys", enterTarget, "${KEY_ENTER}", "");
                            enterTarget = null;
                            preventType = true;
                        } else if (focusValue == enterTarget.value) {
                            while (formChk != "form" && formChk != "body") {
                                tempTarget = tempTarget.parentElement;
                                formChk = tempTarget.tagName.toLowerCase();
                            }
                            if (formChk == "form" && (tempTarget.hasAttribute("id") || tempTarget.hasAttribute("name")) && (!tempTarget.hasAttribute("onsubmit"))) {
                                if (tempTarget.hasAttribute("id"))
                                    record("submit", "", "id=" + tempTarget.id, "");
                                else if (tempTarget.hasAttribute("name"))
                                    record("submit", "", "name=" + tempTarget.name, "");
                            } else
                                record("sendKeys", enterTarget, "${KEY_ENTER}", "");
                            enterTarget = null;
                        }
                        if (typeTarget.tagName && !preventType && (typeLock = 1)) {
                            // END
                            tagName = typeTarget.tagName.toLowerCase();
                            type = typeTarget.type;
                            if ("input" == tagName && inputTypes.indexOf(type) >= 0) {
                                if (typeTarget.value.length > 0) {
                                    record("type", typeTarget, typeTarget.value, "");

                                    if (enterTarget != null) {
                                        tempTarget = typeTarget.parentElement;
                                        formChk = tempTarget.tagName.toLowerCase();
                                        while (formChk != "form" && formChk != "body") {
                                            tempTarget = tempTarget.parentElement;
                                            formChk = tempTarget.tagName.toLowerCase();
                                        }
                                        if (formChk == "form" && (tempTarget.hasAttribute("id") || tempTarget.hasAttribute("name")) && (!tempTarget.hasAttribute("onsubmit"))) {
                                            if (tempTarget.hasAttribute("id"))
                                                record("submit", "", "id=" + tempTarget.id, "");
                                            else if (tempTarget.hasAttribute("name"))
                                                record("submit", "", "name=" + tempTarget.name, "");
                                        } else
                                            record("sendKeys", enterTarget, "${KEY_ENTER}", "");
                                        enterTarget = null;
                                    }
                                    // END
                                } else {
                                    record("type", typeTarget, typeTarget.value, "");
                                }
                            } else if ("textarea" == tagName) {
                                record("type", typeTarget, typeTarget.value, "");
                            }
                        }
                        preventClick = true;
                        setTimeout(function () {
                            preventClick = false;
                        }, 500);
                        setTimeout(function () {
                            if (enterValue != event.target.value) enterTarget = null;
                        }, 50);
                    }

                    var tempbool = false;
                    if ((key == 38 || key == 40) && event.target.value != "") {
                        if (focusTarget != null && focusTarget.value != tempValue) {
                            tempbool = true;
                            tempValue = focusTarget.value;
                        }
                        if (tempbool) {
                            record("type", event.target, tempValue, "");
                        }

                        setTimeout(function () {
                            tempValue = focusTarget.value;
                        }, 250);

                        if (key == 38) record("sendKeys", event.target, "${KEY_UP}", "");
                        else record("sendKeys", event.target, "${KEY_DOWN}", "");
                        tabCheck = event.target;
                    }
                    if (key == 9) {
                        if (tabCheck == event.target) {
                            record("sendKeys", event.target, "${KEY_TAB}", "");
                            preventType = true;
                        }
                    }
                }
            }
        }
    };

    var getEle;
    var checkFocus = 0;
    var contentTest;
    editContentFocusHandler = function (event) {
        console.log(document.SWD_Page_Recorder_Enabled);
        if (document.SWD_Page_Recorder_Enabled) {
            var editable = event.target.contentEditable;
            if (editable == "true") {
                getEle = event.target;
                contentTest = getEle.innerHTML;
                checkFocus = 1;
            }
        }
    };

    editContentBlurHandler = function (event) {
        console.log(document.SWD_Page_Recorder_Enabled);
        if (document.SWD_Page_Recorder_Enabled) {
            if (checkFocus == 1) {
                if (event.target == getEle) {
                    if (getEle.innerHTML != contentTest) {
                        record("editContent", event.target, getEle.innerHTML, "");
                    }
                    checkFocus = 0;
                }
            }
        }
    };

    mouseoverHandler = function (event) {
        highlightEle(event);
    };

    loadHandler = function (event) {
        console.log(document.SWD_Page_Recorder_Enabled);
        if (document.SWD_Page_Recorder_Enabled) {
            if (event.currentTarget.URL) {
                console.warn(event.currentTarget.URL);

                console.info("=======================");
                console.info(event);
                console.info(arguments);
                record("navigation", "", event.currentTarget.URL, "");
            }
        }
    };



    SWD_Page_Recorder = (function () {
        function SWD_Page_Recorder() { }

        SWD_Page_Recorder.prototype.getMainWinElement = function () {
            return document.getElementById('SwdPR_PopUp');
        };

        SWD_Page_Recorder.prototype.displaySwdForm = function (x, y) {
            var el;
            hello('displaySwdForm');
            el = this.getMainWinElement();
            el.style.background = 'white';
            el.style.position = 'absolute';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            el.style.display = 'block';
            el.style.border = '3px solid black';
            el.style.padding = '5px 5px 5px 5px';
            el.style.zIndex = 2147483647;
            return bye('displaySwdForm');
        };

        SWD_Page_Recorder.prototype.showPos = function (event, xpath, css_selector, id, elementText, tagName) {
            var x, y;
            hello('showPos');
            if (window.event) {
                x = window.event.clientX + document.documentElement.scrollLeft + document.body.scrollLeft;
                y = window.event.clientY + document.documentElement.scrollTop + document.body.scrollTop;
            } else {
                x = event.clientX + window.scrollX;
                y = event.clientY + window.scrollY;
            }
            x -= 2;
            y -= 2;
            y = y + 15;
            this.displaySwdForm(x, y);
            document.getElementById('SwdPR_PopUp_XPathLocator').innerHTML = xpath;
            document.getElementById('SwdPR_PopUp_CssSelector').innerHTML = css_selector;
            document.getElementById('SwdPR_PopUp_ElementId').innerHTML = id;
            document.getElementById('SwdPR_PopUp_ElementGUID').innerHTML = pseudoGuid();
            document.getElementById('SwdPR_PopUp_CodeIDText').value = '';
            document.getElementById('SwdPR_PopUp_ElementText').innerHTML = elementText;
            document.getElementById('SwdPR_PopUp_ElementTagName').innerHTML = tagName;
            say(x + ';' + y);
            return bye('showPos');
        };

        SWD_Page_Recorder.prototype.closeForm = function () {
            document.getElementById('SwdPR_PopUp').style.display = 'none';
        };

        var elementFormDIVInnerHtml = '<form name="SWDForm" id="SWDForm">               <table id="SWDTable">                <tr>                  <td>Code identifier</td>                  <td>                    <div id="SwdPR_PopUp_Element_Name">                      <span id="SwdPR_PopUp_CodeID">                        <input type="text" id="SwdPR_PopUp_CodeIDText"/>                      </span>                      <span id="SwdPR_PopUp_CodeClose"/>                      <span id="SwdPR_PopUp_CloseButton" onclick="document.SWD_Page_Recorder.closeForm()">                        <svg width="10" height="10"><circle cx="5" cy="5" r="4" stroke="red" stroke-width="1" fill="pink" />X</svg>                      </span>                    </div>                  </td>                </tr>                <tr>                  <td>                    <input type="radio" name="ElementSelectedBy" id="ElementId"/>                    <label for="ElementId">Id:</label>                  </td>                  <td>                    <span id="SwdPR_PopUp_ElementId">Element Id</span>                  </td>                </tr>                <tr>                  <td>                    <label>GUID:</label>                  </td>                  <td>                    <span id="SwdPR_PopUp_ElementGUID">Element GUID</span>                  </td>                </tr>                <tr>                  <td>                    <input type="radio" name="ElementSelectedBy" id="ElementXPath"/>                    <label for="ElementXPath">XPath:</label>                  </td>                  <td>                    <span id="SwdPR_PopUp_XPathLocator">Element XPath</span>                  </td>                </tr>                <tr>                  <td>                    <input type="radio" name="ElementSelectedBy" id="ElementCssSelector" checked="checked"/>                    <label for="ElementCssSelector">Css:</label>                  </td>                  <td>                    <span id="SwdPR_PopUp_CssSelector">Element Css</span>                  </td>                </tr>                <tr>                  <td>                    <input type="radio" name = "ElementSelectedBy" id="ElementText"/>                    <label for="ElementText">Text:</label>                  </td>                  <td>                    <span id="SwdPR_PopUp_ElementText">Element Text</span>                  </td>                </tr>                <tr>                  <td>                    <input type="radio" name = "ElementSelectedBy" id="ElementTagName" disabled="disabled"/>                    <label for="ElementTagName">TagName:</label>                  </td>                  <td>                    <span id="SwdPR_PopUp_ElementTagName">Element TagName</span>                  </td>                </tr>              </table>              <input type="button" value="Add element" onclick="document.SWD_Page_Recorder.addElement()"/>              </form>';
        SWD_Page_Recorder.prototype.createElementForm = function () {
            var closeClickHandler, element;
            hello('createElementForm');
            element = document.createElement('div');
            element.id = 'SwdPR_PopUp';
            if (document.body != null) {
                document.body.appendChild(element);
            } else {
                say("createElementForm Failed to inject element SwdPR_PopUp. The document has no body");
            }
            // TODO: fix the id
            closeClickHandler = "";

            element.innerHTML = elementFormDIVInnerHtml;
            return bye("createElementForm");
        };

        SWD_Page_Recorder.prototype.addElement = function () {

            var codeIDTextElement = document.getElementById('SwdPR_PopUp_CodeIDText');
            hello('addElement ' + codeIDTextElement.value);
            var htmlIdElement = document.getElementById('SwdPR_PopUp_ElementId');
            var cssSelectorElement = document.getElementById('SwdPR_PopUp_CssSelector');
            var xPathLocatorElement = document.getElementById('SwdPR_PopUp_XPathLocator');
            var elementTextElement = document.getElementById('SwdPR_PopUp_ElementText');
            var elementTagName = document.getElementById('SwdPR_PopUp_ElementTagName');
            var elementSelectedBy = 'ElementCssSelector';

            var radios = document.SWDForm.ElementSelectedBy;
            if (radios) { // this code is unstable
                for (i = 0; i < radios.length; i++) {
                    if (radios[i].checked) {
                        elementSelectedBy = radios[i].getAttribute('id');
                    }
                }
            }
            hello('ElementSelectedBy : ' + elementSelectedBy);
            var JsonData = {
                'Command': 'AddElement',
                'Caller': 'addElement',
                'CommandId': pseudoGuid(),
                'ElementSelectedBy': elementSelectedBy,
                'ElementCodeName': codeIDTextElement.value,
                'ElementId': (htmlIdElement.hasChildNodes()) ? htmlIdElement.firstChild.nodeValue : '',
                'ElementCssSelector': (cssSelectorElement.hasChildNodes()) ? cssSelectorElement.firstChild.nodeValue : '',
                'ElementXPath': (xPathLocatorElement.hasChildNodes()) ? xPathLocatorElement.firstChild.nodeValue : '',
                'ElementText': (elementTextElement.hasChildNodes()) ? elementTextElement.firstChild.nodeValue : '',
                'ElementTagName': (elementTagName.hasChildNodes()) ? elementTagName.firstChild.nodeValue : '',
            };
            createCommand(JsonData);
            return bye('addElement ' + codeIDTextElement.value + '>');
        };

        SWD_Page_Recorder.prototype.removeEventListener = function () {
        
            console.log("===========removeEventListener===============");
            document.removeEventListener('click', clickAtHandler, true);
            document.removeEventListener('mousedown', mouseDownAtHandler, true);
            document.removeEventListener('dblclick', doubleClickAtHandler, true);
            document.removeEventListener('keydown', sendKeysKeyDownHandler, true);
            document.removeEventListener('change', typeChangeHandler, false);
            document.removeEventListener('input', TypeInputHandler, false);
            document.removeEventListener('focus', editContentFocusHandler, true);
            document.removeEventListener('blur', editContentBlurHandler, true);
            document.removeEventListener('load', loadHandler, true);

        };
        return SWD_Page_Recorder;

    })();

    addStyle('.highlight { background-color:green !important}');
    addStyle('table#SWDTable { background-color:white; border-collapse:collapse; } table#SWDTable,table#SWDTable th, table#SWDTable td { font-family: Verdana, Arial; font-size: 10pt; padding-left:10pt; padding-right:10pt; border-bottom: 1px solid black; }');
    addStyle('input#SwdPR_PopUp_CodeIDText { display:table-cell; width:95%; }');
    addStyle('span#SwdPR_PopUp_CloseButton { display:table-cell; -moz-border-radius: 4px; -webkit-border-radius: 4px; -o-border-radius: 4px; border-radius: 4px; border: 1px solid #ccc; color: white; background-color: #980000; cursor: pointer; font-size: 10pt; padding: 0px 2px; font-weight: bold; position: absolute; right: 3px; top: 8px; }');

    /*
    addStyle "span#SwdPR_PopUp_CloseButton {
                display:table-cell;
                width:10px;
                border: 2px solid #c2c2c2;
                padding: 1px 5px;
                top: -20px;
                background-color: #980000;
                border-radius: 20px;
                font-size: 15px;
                font-weight: bold;
                color: white;text-decoration: none; cursor:pointer;
              }"
    */


    addStyle("div#SwdPR_PopUp {             display:none;           }           div#SwdPR_PopUp_Element_Name {             display:table;             width: 100%;           }");

    /*
        Important!
        It wont work if the document has no body, such as top frameset pages.
    */

    if (document.body != null) {
        // var links = document.getElementsByTagName("a");
        // for (var i = 0; i < links.length; i++) {
        //     links.item(i).onclick = function (event) {
        //         if (document.SWD_Page_Recorder_Enabled) {
        //             if (event && event.preventDefault)
        //                 event.preventDefault();
        //             else
        //                 window.event.returnValue = false;
        //         }
        //     };
        // }

        if (document.body.addEventListener) {
            console.log("========== register listner by addEventListener =============");
            //document.body.addEventListener('mouseover', handler, false);
            document.addEventListener('click', clickAtHandler, true);
            document.addEventListener('mousedown', mouseDownAtHandler, true);
            document.addEventListener('dblclick', doubleClickAtHandler, true);
            document.addEventListener('keydown', sendKeysKeyDownHandler, true);
            document.addEventListener('change', typeChangeHandler, false);
            document.addEventListener('input', TypeInputHandler, false);
            document.addEventListener('focus', editContentFocusHandler, true);
            document.addEventListener('blur', editContentBlurHandler, true);
            document.addEventListener('load', loadHandler, true);
            // document.addEventListener('scroll', scrollHandler, true);
            //document.addEventListener('mouseover', mouseoverHandler, true);

        } else if (document.body.attachEvent) {
            console.log("========== register listner by attachEvent =============");
            document.body.attachEvent('click', function (e) {
                return clickAtHandler(e || window.event);
            });
        } else {
            console.log("========== register listner by clickAtHandler =============");
            document.body.onmouseover = clickAtHandler;
        }
        document.swdpr_command = [];

        document.SWD_Page_Recorder_Enabled = true;

        document.SWD_Page_Recorder = new SWD_Page_Recorder();
        document.SWD_Page_Recorder.createElementForm();

        say("Added event listeners.");
    } else {
        say("Document has no body tag... Injecting empty SWD");
        document.SWD_Page_Recorder = "STUB. Document has no body tag :(";
    }

}).call(this);

